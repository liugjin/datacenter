// Generated by IcedCoffeeScript 108.0.12
if (typeof define !== 'function') { var define = require('amdefine')(module) };
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(['underscore', "threejs", "orbit-controls"], function(_, THREE) {
  var Building;
  Building = (function() {
    function Building(element, elementKey) {
      this.dispose = __bind(this.dispose, this);
      this.resize = __bind(this.resize, this);
      this.updateState = __bind(this.updateState, this);
      this.rotate = __bind(this.rotate, this);
      this.getScreenByObj = __bind(this.getScreenByObj, this);
      this.getObjByMouse = __bind(this.getObjByMouse, this);
      this.loadScene = __bind(this.loadScene, this);
      this.element = element.find(elementKey)[0];
      this.height = this.element.offsetHeight;
      this.width = this.element.offsetWidth;
      this.scene = null;
      this.camera = null;
      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      this.renderer.setSize(this.width, this.height);
      this.renderer.setClearColor(0x000000, 0);
      this.renderer.gammaOutput = true;
      this.element.appendChild(this.renderer.domElement);
      this.raycaster = new THREE.Raycaster();
      this.checkList = [];
      this.objs = {};
      this.active = null;
      this.animate = null;
      this.url = null;
      this.loadStatus = false;
    }

    Building.prototype.render = function() {
      this.animate = window.requestAnimationFrame(this.render.bind(this));
      this.orbitControl.update();
      return this.composer.render();
    };

    Building.prototype.setCamera = function(data) {
      var camera, d, p;
      camera = new THREE.PerspectiveCamera(data.fov, this.width / this.height, 0.1, 10000);
      p = Math.PI / 180;
      if (_.has(data, "screen")) {
        d = data.screen;
        camera.position.set(d.x, d.y, d.z);
        camera.rotation.set(p * d.rotationX, p * d.rotationY, p * d.rotationZ);
      } else {
        camera.position.set(data.x, data.y, data.z);
        camera.rotation.set(p * data.rotationX, p * data.rotationY, p * data.rotationZ);
      }
      if (!this.orbitControl) {
        this.orbitControl = new THREE.OrbitControls(camera, this.renderer.domElement);
        this.orbitControl.minPolarAngle = 0;
        this.orbitControl.maxPolarAngle = Math.PI / 2;
      }
      return camera;
    };

    Building.prototype.setScene = function(scene) {
      if (this.scene) {
        this.scene.dispose();
      }
      this.scene = scene;
      this.scene.background = null;
      this.checkList = [];
      this.objs = {};
      this.scene.traverse((function(_this) {
        return function(obj) {
          var _ref, _ref1, _ref2;
          if ((obj != null ? (_ref = obj.name) != null ? _ref[0] : void 0 : void 0) === "$") {
            _this.objs[obj.name.slice(1)] = obj;
          }
          if ((obj != null ? (_ref1 = obj.parent) != null ? (_ref2 = _ref1.name) != null ? _ref2[0] : void 0 : void 0 : void 0) === "$") {
            return _this.checkList.push(obj);
          }
        };
      })(this));
      this.camera = this.setCamera(scene.userData);
      window.cameraHelp = this.camera;
      this.composer = new THREE.EffectComposer(this.renderer);
      this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
      this.outlinePass = new THREE.OutlinePass(new THREE.Vector2(this.width, this.height), this.scene, this.camera);
      this.outlinePass.edgeStrength = 10;
      this.outlinePass.edgeGlow = 1;
      this.outlinePass.edgeThickness = 1;
      this.outlinePass.pulsePeriod = 3;
      this.outlinePass.visibleEdgeColor.set('#35f2d1');
      this.outlinePass.hiddenEdgeColor.set('#30a0de');
      this.outlinePass.selectedObjects = [];
      this.composer.addPass(this.outlinePass);
      this.effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
      this.effectFXAA.uniforms['resolution'].value.set(1 / this.width, 1 / this.height);
      this.effectFXAA.renderToScreen = true;
      this.effectFXAA.clear = true;
      this.composer.addPass(this.effectFXAA);
      this.orbitControl = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.orbitControl.minPolarAngle = 0;
      this.orbitControl.maxPolarAngle = Math.PI / 2;
      return this.render();
    };

    Building.prototype.loadScene = function(url, callback) {
      var error, loader, progess, success;
      if (this.loadStatus && this.url === url) {
        return callback();
      }
      this.loadStatus = false;
      this.url = url;
      loader = new THREE.ObjectLoader;
      success = (function(_this) {
        return function(json) {
          _this.loadStatus = true;
          callback();
          return _this.setScene(json);
        };
      })(this);
      progess = (function(_this) {
        return function(xhr) {
          return callback(parseInt(xhr.loaded * 100 / xhr.total));
        };
      })(this);
      error = function(xhr) {
        return console.error('加载3D文件失败：', xhr);
      };
      return loader.load("/resource/upload/img/public/" + url, success, progess, error);
    };

    Building.prototype.getObjByMouse = function(e) {
      var intersects, key, mouse;
      mouse = new THREE.Vector2();
      mouse.x = (e.offsetX / this.renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = -(e.offsetY / this.renderer.domElement.clientHeight) * 2 + 1;
      this.raycaster.setFromCamera(mouse, this.camera);
      intersects = this.raycaster.intersectObjects(this.checkList);
      if (intersects.length > 0) {
        key = intersects[0].object.parent.name.slice(1);
        this.active = this.objs[key].children;
        this.outlinePass.selectedObjects = this.objs[key].children;
        return intersects[0].object.parent.name.slice(1);
      } else {
        this.active = null;
        this.outlinePass.selectedObjects = [];
        return null;
      }
    };

    Building.prototype.getScreenByObj = function(key) {
      var heightHalf, result, vector, widthHalf;
      if (_.isEmpty(this.objs) || !_.has(this.objs, key)) {
        return;
      }
      vector = new THREE.Vector3();
      vector.setFromMatrixPosition(this.objs[key].matrixWorld);
      vector.project(this.camera);
      widthHalf = this.width / 2;
      heightHalf = this.height / 2;
      result = {
        x: vector.x * widthHalf + widthHalf,
        y: -(vector.y * heightHalf) + heightHalf
      };
      return result;
    };

    Building.prototype.rotate = function() {
      this.orbitControl.autoRotateSpeed = 2;
      return this.orbitControl.autoRotate = !this.orbitControl.autoRotate;
    };

    Building.prototype.updateState = function(key, state) {
      var data;
      data = this.objs[key].userData[state];
      if (!data) {
        return;
      }
      if (_.has(data, "color")) {
        return _.each(this.objs[key].children, (function(_this) {
          return function(obj) {
            return obj.material = new THREE.MeshBasicMaterial({
              color: new THREE.Color(data["color"])
            });
          };
        })(this));
      } else if (_.has(data, "position")) {
        return this.objs[key].position.set(data["position"][0], data["position"][1], data["position"][2]);
      }
    };

    Building.prototype.resize = function() {
      if (typeof this.element.offsetHeight === "number" && this.element.offsetHeight > 0) {
        return;
      }
      if (this.height !== this.element.offsetHeight || this.width !== this.element.offsetWidth) {
        this.height = this.element.offsetHeight;
        this.width = this.element.offsetWidth;
        this.renderer.setSize(this.width, this.height);
        this.camera.aspect = this.width / this.height;
        this.outlinePass = new THREE.OutlinePass(new THREE.Vector2(this.width, this.height), this.scene, this.camera);
        return this.effectFXAA.uniforms['resolution'].value.set(1 / this.width, 1 / this.height);
      }
    };

    Building.prototype.dispose = function() {
      window.cancelAnimationFrame(this.animate);
      this.checkList = [];
      this.objs = {};
      this.active = null;
      this.animate = null;
      this.scene.dispose();
      return $(this.element).empty();
    };

    return Building;

  })();
  return {
    Building: Building
  };
});
